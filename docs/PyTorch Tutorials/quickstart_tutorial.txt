참고Clickhereto download the full example code파이토치(PyTorch) 기본 익히기||빠른 시작||텐서(Tensor)||Dataset과 Dataloader||변형(Transform)||신경망 모델 구성하기||Autograd||최적화(Optimization)||모델 저장하고 불러오기빠른 시작(Quickstart)¶이번 장에서는 기계 학습의 일반적인 작업들을 위한 API를 통해 실행됩니다. 더 자세히 알아보려면 각 장(section)의 링크를 참고하세요.데이터 작업하기¶파이토치(PyTorch)에는데이터 작업을 위한 기본 요소두가지인torch.utils.data.DataLoader와torch.utils.data.Dataset가 있습니다.Dataset은 샘플과 정답(label)을 저장하고,DataLoader는Dataset을 순회 가능한 객체(iterable)로 감쌉니다.importtorchfromtorchimportnnfromtorch.utils.dataimportDataLoaderfromtorchvisionimportdatasetsfromtorchvision.transformsimportToTensorPyTorch는TorchText,TorchVision및TorchAudio와 같이 도메인 특화 라이브러리를 데이터셋과 함께 제공하고 있습니다.
이 튜토리얼에서는 TorchVision 데이터셋을 사용하도록 하겠습니다.torchvision.datasets모듈은 CIFAR, COCO 등과 같은 다양한 실제 비전(vision) 데이터에 대한Dataset(전체 목록은 여기)을 포함하고 있습니다.
이 튜토리얼에서는 FasionMNIST 데이터셋을 사용합니다.
모든 TorchVisionDataset은 샘플과 정답을 각각 변경하기 위한transform과target_transform의 두 인자를 포함합니다.# 공개 데이터셋에서 학습 데이터를 내려받습니다.training_data=datasets.FashionMNIST(root="data",train=True,download=True,transform=ToTensor(),)# 공개 데이터셋에서 테스트 데이터를 내려받습니다.test_data=datasets.FashionMNIST(root="data",train=False,download=True,transform=ToTensor(),)Dataset을DataLoader의 인자로 전달합니다. 이는 데이터셋을 순회 가능한 객체(iterable)로 감싸고, 자동화된 배치(batch), 샘플링(sampling),
섞기(shuffle) 및 다중 프로세스로 데이터 불러오기(multiprocess data loading)를 지원합니다. 여기서는 배치 크기(batch size)를 64로 정의합니다.
즉, 데이터로더(dataloader) 객체의 각 요소는 64개의 특징(feature)과 정답(label)을 묶음(batch)으로 반환합니다.batch_size=64# 데이터로더를 생성합니다.train_dataloader=DataLoader(training_data,batch_size=batch_size)test_dataloader=DataLoader(test_data,batch_size=batch_size)forX,yintest_dataloader:print(f"Shape of X [N, C, H, W]:{X.shape}")print(f"Shape of y:{y.shape}{y.dtype}")breakShape of X [N, C, H, W]: torch.Size([64, 1, 28, 28])
Shape of y: torch.Size([64]) torch.int64PyTorch에서 데이터를 불러오는 방법을 자세히 알아보세요.모델 만들기¶PyTorch에서 신경망 모델은nn.Module을
상속받는 클래스(class)를 생성하여 정의합니다.__init__함수에서 신경망의 계층(layer)들을 정의하고forward함수에서
신경망에 데이터를 어떻게 전달할지 지정합니다. 가능한 경우 GPU 또는 MPS로 신경망을 이동시켜 연산을 가속(accelerate)합니다.# 학습에 사용할 CPU나 GPU, MPS 장치를 얻습니다.device=("cuda"iftorch.cuda.is_available()else"mps"iftorch.backends.mps.is_available()else"cpu")print(f"Using{device}device")# 모델을 정의합니다.classNeuralNetwork(nn.Module):def__init__(self):super().__init__()self.flatten=nn.Flatten()self.linear_relu_stack=nn.Sequential(nn.Linear(28*28,512),nn.ReLU(),nn.Linear(512,512),nn.ReLU(),nn.Linear(512,10))defforward(self,x):x=self.flatten(x)logits=self.linear_relu_stack(x)returnlogitsmodel=NeuralNetwork().to(device)print(model)Using cuda device
NeuralNetwork(
  (flatten): Flatten(start_dim=1, end_dim=-1)
  (linear_relu_stack): Sequential(
    (0): Linear(in_features=784, out_features=512, bias=True)
    (1): ReLU()
    (2): Linear(in_features=512, out_features=512, bias=True)
    (3): ReLU()
    (4): Linear(in_features=512, out_features=10, bias=True)
  )
)PyTorch에서 신경망을 정의하는 방법을 자세히 알아보세요.모델 매개변수 최적화하기¶모델을 학습하려면손실 함수(loss function)와옵티마이저(optimizer)가 필요합니다.loss_fn=nn.CrossEntropyLoss()optimizer=torch.optim.SGD(model.parameters(),lr=1e-3)각 학습 단계(training loop)에서 모델은 (배치(batch)로 제공되는) 학습 데이터셋에 대한 예측을 수행하고,
예측 오류를 역전파하여 모델의 매개변수를 조정합니다.deftrain(dataloader,model,loss_fn,optimizer):size=len(dataloader.dataset)forbatch,(X,y)inenumerate(dataloader):X,y=X.to(device),y.to(device)# 예측 오류 계산pred=model(X)loss=loss_fn(pred,y)# 역전파loss.backward()optimizer.step()optimizer.zero_grad()ifbatch%100==0:loss,current=loss.item(),(batch+1)*len(X)print(f"loss:{loss:>7f}[{current:>5d}/{size:>5d}]")모델이 학습하고 있는지를 확인하기 위해 테스트 데이터셋으로 모델의 성능을 확인합니다.deftest(dataloader,model,loss_fn):size=len(dataloader.dataset)num_batches=len(dataloader)model.eval()test_loss,correct=0,0withtorch.no_grad():forX,yindataloader:X,y=X.to(device),y.to(device)pred=model(X)test_loss+=loss_fn(pred,y).item()correct+=(pred.argmax(1)==y).type(torch.float).sum().item()test_loss/=num_batchescorrect/=sizeprint(f"Test Error:\nAccuracy:{(100*correct):>0.1f}%, Avg loss:{test_loss:>8f}\n")학습 단계는 여러번의 반복 단계 (에폭(epochs)) 를 거쳐서 수행됩니다. 각 에폭에서는 모델은 더 나은 예측을 하기 위해  매개변수를 학습합니다.
각 에폭마다 모델의 정확도(accuracy)와 손실(loss)을 출력합니다; 에폭마다 정확도가 증가하고 손실이 감소하는 것을 보려고 합니다.epochs=5fortinrange(epochs):print(f"Epoch{t+1}\n-------------------------------")train(train_dataloader,model,loss_fn,optimizer)test(test_dataloader,model,loss_fn)print("Done!")Epoch 1
-------------------------------
loss: 2.303494  [   64/60000]
loss: 2.294637  [ 6464/60000]
loss: 2.277102  [12864/60000]
loss: 2.269977  [19264/60000]
loss: 2.254234  [25664/60000]
loss: 2.237145  [32064/60000]
loss: 2.231056  [38464/60000]
loss: 2.205036  [44864/60000]
loss: 2.203239  [51264/60000]
loss: 2.170890  [57664/60000]
Test Error:
 Accuracy: 53.9%, Avg loss: 2.168587

Epoch 2
-------------------------------
loss: 2.177784  [   64/60000]
loss: 2.168083  [ 6464/60000]
loss: 2.114908  [12864/60000]
loss: 2.130411  [19264/60000]
loss: 2.087470  [25664/60000]
loss: 2.039667  [32064/60000]
loss: 2.054271  [38464/60000]
loss: 1.985452  [44864/60000]
loss: 1.996019  [51264/60000]
loss: 1.917239  [57664/60000]
Test Error:
 Accuracy: 60.2%, Avg loss: 1.920371

Epoch 3
-------------------------------
loss: 1.951699  [   64/60000]
loss: 1.919513  [ 6464/60000]
loss: 1.808724  [12864/60000]
loss: 1.846544  [19264/60000]
loss: 1.740612  [25664/60000]
loss: 1.698728  [32064/60000]
loss: 1.708887  [38464/60000]
loss: 1.614431  [44864/60000]
loss: 1.646473  [51264/60000]
loss: 1.524302  [57664/60000]
Test Error:
 Accuracy: 61.4%, Avg loss: 1.547089

Epoch 4
-------------------------------
loss: 1.612693  [   64/60000]
loss: 1.570868  [ 6464/60000]
loss: 1.424729  [12864/60000]
loss: 1.489538  [19264/60000]
loss: 1.367247  [25664/60000]
loss: 1.373463  [32064/60000]
loss: 1.376742  [38464/60000]
loss: 1.304958  [44864/60000]
loss: 1.347153  [51264/60000]
loss: 1.230657  [57664/60000]
Test Error:
 Accuracy: 62.7%, Avg loss: 1.260888

Epoch 5
-------------------------------
loss: 1.337799  [   64/60000]
loss: 1.313273  [ 6464/60000]
loss: 1.151835  [12864/60000]
loss: 1.252141  [19264/60000]
loss: 1.123040  [25664/60000]
loss: 1.159529  [32064/60000]
loss: 1.175010  [38464/60000]
loss: 1.115551  [44864/60000]
loss: 1.160972  [51264/60000]
loss: 1.062725  [57664/60000]
Test Error:
 Accuracy: 64.6%, Avg loss: 1.087372

Done!모델을 학습하는 방법을 자세히 알아보세요.모델 저장하기¶모델을 저장하는 일반적인 방법은 (모델의 매개변수들을 포함하여) 내부 상태 사전(internal state dictionary)을
직렬화(serialize)하는 것입니다.torch.save(model.state_dict(),"model.pth")print("Saved PyTorch Model State to model.pth")Saved PyTorch Model State to model.pth모델 불러오기¶모델을 불러오는 과정에는 모델 구조를 다시 만들고 상태 사전을 모델에 불러오는 과정이 포함됩니다.model=NeuralNetwork().to(device)model.load_state_dict(torch.load("model.pth"))<All keys matched successfully>이제 이 모델을 사용해서 예측을 할 수 있습니다.classes=["T-shirt/top","Trouser","Pullover","Dress","Coat","Sandal","Shirt","Sneaker","Bag","Ankle boot",]model.eval()x,y=test_data[0][0],test_data[0][1]withtorch.no_grad():x=x.to(device)pred=model(x)predicted,actual=classes[pred[0].argmax(0)],classes[y]print(f'Predicted: "{predicted}", Actual: "{actual}"')Predicted: "Ankle boot", Actual: "Ankle boot"모델을 저장하고 불러오는 방법을 자세히 알아보세요.Total running time of the script:( 0 minutes  23.454 seconds)DownloadPythonsourcecode:quickstart_tutorial.pyDownloadJupyternotebook:quickstart_tutorial.ipynbGallery generated by Sphinx-Gallery