참고Clickhereto download the full example code컴퓨터 비전(Vision)을 위한 전이학습(Transfer Learning)¶Author:Sasank Chilamkurthy번역:박정환이 튜토리얼에서는 전이학습(Transfer Learning)을 이용하여 이미지 분류를 위한
합성곱 신경망을 어떻게 학습시키는지 배워보겠습니다. 전이학습에 대해서는CS231n 노트에서 더 많은 내용을
읽어보실 수 있습니다.위 노트를 인용해보면,실제로 충분한 크기의 데이터셋을 갖추기는 상대적으로 드물기 때문에,
(무작위 초기화를 통해) 맨 처음부터 합성곱 신경망(Convolutional
Network) 전체를 학습하는 사람은 매우 적습니다. 대신, 매우 큰 데이터셋(예.
100가지 분류에 대해 120만개의 이미지가 포함된 ImageNet)에서 합성곱
신경망(ConvNet)을 미리 학습한 후, 이 합성곱 신경망을 관심있는 작업
을 위한 초기 설정 또는 고정된 특징 추출기(fixed feature extractor)로 사용합니다.이러한 전이학습 시나리오의 주요한 2가지는 다음과 같습니다:합성곱 신경망의 미세조정(finetuning): 무작위 초기화 대신, 신경망을
ImageNet 1000 데이터셋 등으로 미리 학습한 신경망으로 초기화합니다. 학습의 나머지
과정들은 평상시와 같습니다.고정된 특징 추출기로써의 합성곱 신경망: 여기서는 마지막에 완전히 연결
된 계층을 제외한 모든 신경망의 가중치를 고정합니다. 이 마지막의 완전히 연결된
계층은 새로운 무작위의 가중치를 갖는 계층으로 대체되어 이 계층만 학습합니다.# License: BSD# Author: Sasank Chilamkurthyimporttorchimporttorch.nnasnnimporttorch.optimasoptimfromtorch.optimimportlr_schedulerimporttorch.backends.cudnnascudnnimportnumpyasnpimporttorchvisionfromtorchvisionimportdatasets,models,transformsimportmatplotlib.pyplotaspltimporttimeimportosfromPILimportImagefromtempfileimportTemporaryDirectorycudnn.benchmark=Trueplt.ion()# 대화형 모드<contextlib.ExitStack object at 0x7789ec36d660>데이터 불러오기¶데이터를 불러오기 위해 torchvision과 torch.utils.data 패키지를 사용하겠습니다.여기서 풀고자 하는 문제는개미와벌을 분류하는 모델을 학습하는 것입니다.
개미와 벌 각각의 학습용 이미지는 대략 120장 정도 있고, 75개의 검증용 이미지가
있습니다. 일반적으로 맨 처음부터 학습을 한다면 이는 일반화하기에는 아주 작은
데이터셋입니다. 하지만 우리는 전이학습을 할 것이므로, 일반화를 제법 잘 할 수 있을
것입니다.이 데이터셋은 ImageNet의 아주 작은 일부입니다.참고데이터를여기에서 다운로드 받아 현재 디렉토리에 압축을 푸십시오.# 학습을 위해 데이터 증가(augmentation) 및 일반화(normalization)# 검증을 위한 일반화data_transforms={'train':transforms.Compose([transforms.RandomResizedCrop(224),transforms.RandomHorizontalFlip(),transforms.ToTensor(),transforms.Normalize([0.485,0.456,0.406],[0.229,0.224,0.225])]),'val':transforms.Compose([transforms.Resize(256),transforms.CenterCrop(224),transforms.ToTensor(),transforms.Normalize([0.485,0.456,0.406],[0.229,0.224,0.225])]),}data_dir='data/hymenoptera_data'image_datasets={x:datasets.ImageFolder(os.path.join(data_dir,x),data_transforms[x])forxin['train','val']}dataloaders={x:torch.utils.data.DataLoader(image_datasets[x],batch_size=4,shuffle=True,num_workers=4)forxin['train','val']}dataset_sizes={x:len(image_datasets[x])forxin['train','val']}class_names=image_datasets['train'].classesdevice=torch.device("cuda:0"iftorch.cuda.is_available()else"cpu")일부 이미지 시각화하기¶데이터 증가를 이해하기 위해 일부 학습용 이미지를 시각화해보겠습니다.defimshow(inp,title=None):"""tensor를 입력받아 일반적인 이미지로 보여줍니다."""inp=inp.numpy().transpose((1,2,0))mean=np.array([0.485,0.456,0.406])std=np.array([0.229,0.224,0.225])inp=std*inp+meaninp=np.clip(inp,0,1)plt.imshow(inp)iftitleisnotNone:plt.title(title)plt.pause(0.001)# 갱신이 될 때까지 잠시 기다립니다.# 학습 데이터의 배치를 얻습니다.inputs,classes=next(iter(dataloaders['train']))# 배치로부터 격자 형태의 이미지를 만듭니다.out=torchvision.utils.make_grid(inputs)imshow(out,title=[class_names[x]forxinclasses])모델 학습하기¶이제 모델을 학습하기 위한 일반 함수를 작성해보겠습니다. 여기서는 다음 내용들을
설명합니다:학습률(learning rate) 관리(scheduling)최적의 모델 구하기아래에서scheduler매개변수는torch.optim.lr_scheduler의 LR 스케쥴러
객체(Object)입니다.deftrain_model(model,criterion,optimizer,scheduler,num_epochs=25):since=time.time()# Create a temporary directory to save training checkpointswithTemporaryDirectory()astempdir:best_model_params_path=os.path.join(tempdir,'best_model_params.pt')torch.save(model.state_dict(),best_model_params_path)best_acc=0.0forepochinrange(num_epochs):print(f'Epoch{epoch}/{num_epochs-1}')print('-'*10)# 각 에폭(epoch)은 학습 단계와 검증 단계를 갖습니다.forphasein['train','val']:ifphase=='train':model.train()# 모델을 학습 모드로 설정else:model.eval()# 모델을 평가 모드로 설정running_loss=0.0running_corrects=0# 데이터를 반복forinputs,labelsindataloaders[phase]:inputs=inputs.to(device)labels=labels.to(device)# 매개변수 경사도를 0으로 설정optimizer.zero_grad()# 순전파# 학습 시에만 연산 기록을 추적withtorch.set_grad_enabled(phase=='train'):outputs=model(inputs)_,preds=torch.max(outputs,1)loss=criterion(outputs,labels)# 학습 단계인 경우 역전파 + 최적화ifphase=='train':loss.backward()optimizer.step()# 통계running_loss+=loss.item()*inputs.size(0)running_corrects+=torch.sum(preds==labels.data)ifphase=='train':scheduler.step()epoch_loss=running_loss/dataset_sizes[phase]epoch_acc=running_corrects.double()/dataset_sizes[phase]print(f'{phase}Loss:{epoch_loss:.4f}Acc:{epoch_acc:.4f}')# 모델을 깊은 복사(deep copy)함ifphase=='val'andepoch_acc>best_acc:best_acc=epoch_acctorch.save(model.state_dict(),best_model_params_path)print()time_elapsed=time.time()-sinceprint(f'Training complete in{time_elapsed//60:.0f}m{time_elapsed%60:.0f}s')print(f'Best val Acc:{best_acc:4f}')# 가장 나은 모델 가중치를 불러오기model.load_state_dict(torch.load(best_model_params_path))returnmodel모델 예측값 시각화하기¶일부 이미지에 대한 예측값을 보여주는 일반화된 함수입니다.defvisualize_model(model,num_images=6):was_training=model.trainingmodel.eval()images_so_far=0fig=plt.figure()withtorch.no_grad():fori,(inputs,labels)inenumerate(dataloaders['val']):inputs=inputs.to(device)labels=labels.to(device)outputs=model(inputs)_,preds=torch.max(outputs,1)forjinrange(inputs.size()[0]):images_so_far+=1ax=plt.subplot(num_images//2,2,images_so_far)ax.axis('off')ax.set_title(f'predicted:{class_names[preds[j]]}')imshow(inputs.cpu().data[j])ifimages_so_far==num_images:model.train(mode=was_training)returnmodel.train(mode=was_training)합성곱 신경망 미세조정(finetuning)¶미리 학습한 모델을 불러온 후 마지막의 완전히 연결된 계층을 초기화합니다.model_ft=models.resnet18(weights='IMAGENET1K_V1')num_ftrs=model_ft.fc.in_features# 여기서 각 출력 샘플의 크기는 2로 설정합니다.# 또는, ``nn.Linear(num_ftrs, len (class_names))`` 로 일반화할 수 있습니다.model_ft.fc=nn.Linear(num_ftrs,2)model_ft=model_ft.to(device)criterion=nn.CrossEntropyLoss()# 모든 매개변수들이 최적화되었는지 관찰optimizer_ft=optim.SGD(model_ft.parameters(),lr=0.001,momentum=0.9)# 7 에폭마다 0.1씩 학습률 감소exp_lr_scheduler=lr_scheduler.StepLR(optimizer_ft,step_size=7,gamma=0.1)Downloading: "https://download.pytorch.org/models/resnet18-f37072fd.pth" to /root/.cache/torch/hub/checkpoints/resnet18-f37072fd.pth

  0%|          | 0.00/44.7M [00:00<?, ?B/s]
 19%|#9        | 8.62M/44.7M [00:00<00:00, 90.1MB/s]
 43%|####3     | 19.2M/44.7M [00:00<00:00, 103MB/s]
 66%|######6   | 29.6M/44.7M [00:00<00:00, 105MB/s]
 91%|#########1| 40.8M/44.7M [00:00<00:00, 109MB/s]
100%|##########| 44.7M/44.7M [00:00<00:00, 107MB/s]학습 및 평가하기¶CPU에서는 15-25분 가량, GPU에서는 1분 이내의 시간이 걸립니다.model_ft=train_model(model_ft,criterion,optimizer_ft,exp_lr_scheduler,num_epochs=25)Epoch 0/24
----------
train Loss: 0.4773 Acc: 0.7582
val Loss: 0.2798 Acc: 0.8824

Epoch 1/24
----------
train Loss: 0.5301 Acc: 0.8033
val Loss: 0.5958 Acc: 0.7516

Epoch 2/24
----------
train Loss: 0.4256 Acc: 0.8115
val Loss: 0.2863 Acc: 0.8824

Epoch 3/24
----------
train Loss: 0.6194 Acc: 0.7459
val Loss: 0.4157 Acc: 0.8497

Epoch 4/24
----------
train Loss: 0.3989 Acc: 0.8525
val Loss: 0.2317 Acc: 0.9281

Epoch 5/24
----------
train Loss: 0.4815 Acc: 0.8033
val Loss: 0.2903 Acc: 0.8758

Epoch 6/24
----------
train Loss: 0.3830 Acc: 0.8402
val Loss: 0.5108 Acc: 0.8235

Epoch 7/24
----------
train Loss: 0.3982 Acc: 0.8279
val Loss: 0.1944 Acc: 0.9346

Epoch 8/24
----------
train Loss: 0.2271 Acc: 0.9180
val Loss: 0.2058 Acc: 0.9346

Epoch 9/24
----------
train Loss: 0.2701 Acc: 0.8770
val Loss: 0.2246 Acc: 0.9216

Epoch 10/24
----------
train Loss: 0.3478 Acc: 0.8484
val Loss: 0.1813 Acc: 0.9542

Epoch 11/24
----------
train Loss: 0.3266 Acc: 0.8566
val Loss: 0.2888 Acc: 0.8758

Epoch 12/24
----------
train Loss: 0.2320 Acc: 0.9098
val Loss: 0.2258 Acc: 0.9281

Epoch 13/24
----------
train Loss: 0.2965 Acc: 0.8811
val Loss: 0.1972 Acc: 0.9412

Epoch 14/24
----------
train Loss: 0.2546 Acc: 0.8934
val Loss: 0.2399 Acc: 0.9281

Epoch 15/24
----------
train Loss: 0.2877 Acc: 0.8648
val Loss: 0.2937 Acc: 0.8758

Epoch 16/24
----------
train Loss: 0.2051 Acc: 0.9180
val Loss: 0.2162 Acc: 0.9346

Epoch 17/24
----------
train Loss: 0.2285 Acc: 0.9221
val Loss: 0.1781 Acc: 0.9477

Epoch 18/24
----------
train Loss: 0.2663 Acc: 0.8852
val Loss: 0.2441 Acc: 0.9216

Epoch 19/24
----------
train Loss: 0.2053 Acc: 0.9098
val Loss: 0.1933 Acc: 0.9412

Epoch 20/24
----------
train Loss: 0.2672 Acc: 0.8852
val Loss: 0.2087 Acc: 0.9346

Epoch 21/24
----------
train Loss: 0.2508 Acc: 0.9057
val Loss: 0.2522 Acc: 0.9085

Epoch 22/24
----------
train Loss: 0.3275 Acc: 0.8566
val Loss: 0.1985 Acc: 0.9412

Epoch 23/24
----------
train Loss: 0.2879 Acc: 0.8770
val Loss: 0.2170 Acc: 0.9281

Epoch 24/24
----------
train Loss: 0.3075 Acc: 0.8689
val Loss: 0.1842 Acc: 0.9477

Training complete in 0m 47s
Best val Acc: 0.954248visualize_model(model_ft)고정된 특징 추출기로써의 합성곱 신경망¶이제, 마지막 계층을 제외한 신경망의 모든 부분을 고정해야 합니다.requires_grad=False로 설정하여 매개변수를 고정하여backward()중에
경사도가 계산되지 않도록 해야합니다.이에 대한 문서는여기에서 확인할 수 있습니다.model_conv=torchvision.models.resnet18(weights='IMAGENET1K_V1')forparaminmodel_conv.parameters():param.requires_grad=False# 새로 생성된 모듈의 매개변수는 기본값이 requires_grad=True 임num_ftrs=model_conv.fc.in_featuresmodel_conv.fc=nn.Linear(num_ftrs,2)model_conv=model_conv.to(device)criterion=nn.CrossEntropyLoss()# 이전과는 다르게 마지막 계층의 매개변수들만 최적화되는지 관찰optimizer_conv=optim.SGD(model_conv.fc.parameters(),lr=0.001,momentum=0.9)# 7 에폭마다 0.1씩 학습률 감소exp_lr_scheduler=lr_scheduler.StepLR(optimizer_conv,step_size=7,gamma=0.1)학습 및 평가하기¶CPU에서 실행하는 경우 이전과 비교했을 때 약 절반 가량의 시간만이 소요될 것입니다.
이는 대부분의 신경망에서 경사도를 계산할 필요가 없기 때문입니다. 하지만,
순전파는 계산이 필요합니다.model_conv=train_model(model_conv,criterion,optimizer_conv,exp_lr_scheduler,num_epochs=25)Epoch 0/24
----------
train Loss: 0.6996 Acc: 0.6516
val Loss: 0.2014 Acc: 0.9346

Epoch 1/24
----------
train Loss: 0.4233 Acc: 0.8033
val Loss: 0.2656 Acc: 0.8758

Epoch 2/24
----------
train Loss: 0.4602 Acc: 0.7869
val Loss: 0.1847 Acc: 0.9477

Epoch 3/24
----------
train Loss: 0.3096 Acc: 0.8566
val Loss: 0.1747 Acc: 0.9477

Epoch 4/24
----------
train Loss: 0.4427 Acc: 0.8156
val Loss: 0.1630 Acc: 0.9477

Epoch 5/24
----------
train Loss: 0.5505 Acc: 0.7828
val Loss: 0.1642 Acc: 0.9477

Epoch 6/24
----------
train Loss: 0.3004 Acc: 0.8607
val Loss: 0.1744 Acc: 0.9542

Epoch 7/24
----------
train Loss: 0.4083 Acc: 0.8361
val Loss: 0.1892 Acc: 0.9412

Epoch 8/24
----------
train Loss: 0.4483 Acc: 0.7910
val Loss: 0.1983 Acc: 0.9477

Epoch 9/24
----------
train Loss: 0.3335 Acc: 0.8279
val Loss: 0.1942 Acc: 0.9412

Epoch 10/24
----------
train Loss: 0.2413 Acc: 0.8934
val Loss: 0.2001 Acc: 0.9477

Epoch 11/24
----------
train Loss: 0.3107 Acc: 0.8689
val Loss: 0.1801 Acc: 0.9412

Epoch 12/24
----------
train Loss: 0.3032 Acc: 0.8689
val Loss: 0.1669 Acc: 0.9477

Epoch 13/24
----------
train Loss: 0.3586 Acc: 0.8525
val Loss: 0.1900 Acc: 0.9477

Epoch 14/24
----------
train Loss: 0.2771 Acc: 0.8893
val Loss: 0.2318 Acc: 0.9216

Epoch 15/24
----------
train Loss: 0.3064 Acc: 0.8852
val Loss: 0.1909 Acc: 0.9477

Epoch 16/24
----------
train Loss: 0.4243 Acc: 0.8238
val Loss: 0.2227 Acc: 0.9346

Epoch 17/24
----------
train Loss: 0.3297 Acc: 0.8238
val Loss: 0.1917 Acc: 0.9412

Epoch 18/24
----------
train Loss: 0.4235 Acc: 0.8238
val Loss: 0.1766 Acc: 0.9477

Epoch 19/24
----------
train Loss: 0.2500 Acc: 0.8934
val Loss: 0.2003 Acc: 0.9477

Epoch 20/24
----------
train Loss: 0.2413 Acc: 0.8934
val Loss: 0.1820 Acc: 0.9477

Epoch 21/24
----------
train Loss: 0.3762 Acc: 0.8115
val Loss: 0.1842 Acc: 0.9412

Epoch 22/24
----------
train Loss: 0.3485 Acc: 0.8566
val Loss: 0.2166 Acc: 0.9281

Epoch 23/24
----------
train Loss: 0.3626 Acc: 0.8361
val Loss: 0.1747 Acc: 0.9412

Epoch 24/24
----------
train Loss: 0.3840 Acc: 0.8320
val Loss: 0.1767 Acc: 0.9412

Training complete in 0m 39s
Best val Acc: 0.954248visualize_model(model_conv)plt.ioff()plt.show()다른 이미지들에 대한 추론¶학습된 모델을 사용하여 사용자 지정 이미지에 대해 예측하고,
예측된 클래스 레이블을 이미지와 함께 시각화합니다.defvisualize_model_predictions(model,img_path):was_training=model.trainingmodel.eval()img=Image.open(img_path)img=data_transforms['val'](img)img=img.unsqueeze(0)img=img.to(device)withtorch.no_grad():outputs=model(img)_,preds=torch.max(outputs,1)ax=plt.subplot(2,2,1)ax.axis('off')ax.set_title(f'Predicted:{class_names[preds[0]]}')imshow(img.cpu().data[0])model.train(mode=was_training)visualize_model_predictions(model_conv,img_path='data/hymenoptera_data/val/bees/72100438_73de9f17af.jpg')plt.ioff()plt.show()더 배워볼 내용¶전이학습의 응용 사례(application)들을 더 알아보려면,(베타) 컴퓨터 비전 튜토리얼을 위한 양자화된 전이학습(Quantized Transfer Learning)을 참조해보세요.Total running time of the script:( 1 minutes  29.685 seconds)DownloadPythonsourcecode:transfer_learning_tutorial.pyDownloadJupyternotebook:transfer_learning_tutorial.ipynbGallery generated by Sphinx-Gallery